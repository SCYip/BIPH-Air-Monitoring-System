<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campus Air Quality Monitor - Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <!-- Firebase SDK -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, doc, updateDoc, deleteDoc, query, where } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDUwRP7cX-h0Z8GUqamFdvvlk6W1OUzow4",
            authDomain: "biph-aqs.firebaseapp.com",
            projectId: "biph-aqs",
            storageBucket: "biph-aqs.firebasestorage.app",
            messagingSenderId: "799342583781",
            appId: "1:799342583781:web:383bd60532fd1017d2590c",
            measurementId: "G-YT0SXNDC10"
        };

        try {
            console.log('üîÑ [Dashboard] Initializing Firebase...');
            // Initialize Firebase
            const app = initializeApp(firebaseConfig);
            console.log('‚úÖ [Dashboard] Firebase app initialized');

            const db = getFirestore(app);
            console.log('‚úÖ [Dashboard] Firestore initialized');

            // Make Firebase available globally
            window.firebase = { db, collection, addDoc, getDocs, doc, updateDoc, deleteDoc, query, where };
            console.log('‚úÖ [Dashboard] Firebase SDK ready for use');

        } catch (error) {
            console.error('‚ùå [Dashboard] Firebase initialization failed:', error);
            console.error('Error details:', error.message);
            console.error('Error code:', error.code);
            alert('Firebase initialization failed: ' + error.message);
        }
    </script>
    <script>
        /**
         * Campus Air Quality Monitor - Data Management Module
         * Provides CRUD operations for location data with ThingSpeak integration
         */

        class LocationManager {
            constructor() {
                this.collectionName = 'locations';
                this.locations = [];
                this.initialized = false;
            }

            // Initialize - load locations from Firestore
            async initialize() {
                if (this.initialized) return;

                // Wait briefly for the Firebase SDK to be set by the module script.
                const start = Date.now();
                const timeoutMs = 5000;
                while ((!window.firebase || !window.firebase.db) && (Date.now() - start) < timeoutMs) {
                    await new Promise(r => setTimeout(r, 100));
                }

                if (!window.firebase || !window.firebase.db) {
                    console.warn('Firebase not ready after wait; initialize will attempt to proceed but may fail.');
                }

                try {
                    await this.loadLocations();
                    this.initialized = true;
                } catch (error) {
                    console.error('Error initializing LocationManager:', error);
                }
            }

            // Load locations from Firestore
            async loadLocations() {
                try {
                    const { db, collection, getDocs } = window.firebase;
                    const querySnapshot = await getDocs(collection(db, this.collectionName));
                    this.locations = [];
                    querySnapshot.forEach((doc) => {
                        this.locations.push({ id: doc.id, ...doc.data() });
                    });
                    return this.locations;
                } catch (error) {
                    console.error('Error loading locations from Firestore:', error);
                    return [];
                }
            }

            // CRUD Operations
            async getAllLocations() {
                if (!this.initialized) await this.initialize();
                return [...this.locations];
            }

            async getLocationById(id) {
                if (!this.initialized) await this.initialize();
                return this.locations.find(loc => loc.id === id);
            }

            async createLocation(locationData) {
                try {
                    const { db, collection, addDoc } = window.firebase;
                    const newLocation = {
                        name: locationData.name || 'Unnamed Location',
                        channelId: locationData.channelId || '',
                        readKey: locationData.readKey || '',
                        lastUpdate: null,
                        createdAt: new Date()
                    };

                    const docRef = await addDoc(collection(db, this.collectionName), newLocation);
                    const locationWithId = { id: docRef.id, ...newLocation };
                    this.locations.push(locationWithId);
                    return locationWithId;
                } catch (error) {
                    console.error('Error creating location:', error);
                    throw error;
                }
            }

            async updateLocation(id, updates) {
                try {
                    const { db, doc, updateDoc } = window.firebase;
                    const locationRef = doc(db, this.collectionName, id);
                    await updateDoc(locationRef, {
                        ...updates,
                        updatedAt: new Date()
                    });

                    // Update local cache
                    const index = this.locations.findIndex(loc => loc.id === id);
                    if (index >= 0) {
                        this.locations[index] = { ...this.locations[index], ...updates };
                        return this.locations[index];
                    }
                    return null;
                } catch (error) {
                    console.error('Error updating location:', error);
                    throw error;
                }
            }

            async deleteLocation(id) {
                try {
                    const { db, doc, deleteDoc } = window.firebase;
                    await deleteDoc(doc(db, this.collectionName, id));

                    // Update local cache
                    const index = this.locations.findIndex(loc => loc.id === id);
                    if (index >= 0) {
                        const deleted = this.locations.splice(index, 1)[0];
                        return deleted;
                    }
                    return null;
                } catch (error) {
                    console.error('Error deleting location:', error);
                    throw error;
                }
            }

            // Utility functions
            async exportToJSON() {
                const locations = await this.getAllLocations();
                return JSON.stringify(locations, null, 2);
            }

            async importFromJSON(jsonString) {
                try {
                    const imported = JSON.parse(jsonString);
                    if (Array.isArray(imported)) {
                        // Clear existing locations and add imported ones
                        for (const location of imported) {
                            await this.createLocation(location);
                        }
                        return true;
                    }
                    return false;
                } catch (error) {
                    console.error('Error importing locations:', error);
                    return false;
                }
            }

            async resetToDefaults() {
                // This would clear all locations in Firestore
                const locations = await this.getAllLocations();
                for (const location of locations) {
                    await this.deleteLocation(location.id);
                }
                this.locations = [];
            }

            // Validation
            validateLocationData(data) {
                const errors = [];
                if (!data.name || data.name.trim().length === 0) {
                    errors.push('Location name is required');
                }
                if (data.channelId && !/^\d+$/.test(data.channelId)) {
                    errors.push('Channel ID must be numeric');
                }
                if (data.readKey && data.readKey.length < 16) {
                    errors.push('Read API key appears to be too short');
                }
                return errors;
            }

            // Bulk operations
            async createMultipleLocations(locationsArray) {
                const results = [];
                for (const locData of locationsArray) {
                    const errors = this.validateLocationData(locData);
                    if (errors.length === 0) {
                        try {
                            const result = await this.createLocation(locData);
                            results.push(result);
                        } catch (error) {
                            console.warn(`Error creating location: ${error.message}`);
                        }
                    } else {
                        console.warn(`Skipping invalid location: ${errors.join(', ')}`);
                    }
                }
                return results;
            }

            // Search and filter
            async searchLocations(query) {
                const locations = await this.getAllLocations();
                const lowercaseQuery = query.toLowerCase();
                return locations.filter(loc =>
                    loc.name.toLowerCase().includes(lowercaseQuery) ||
                    loc.id.toLowerCase().includes(lowercaseQuery)
                );
            }

            async getConfiguredLocations() {
                const locations = await this.getAllLocations();
                return locations.filter(loc => loc.channelId && loc.readKey);
            }

            async getUnconfiguredLocations() {
                const locations = await this.getAllLocations();
                return locations.filter(loc => !loc.channelId || !loc.readKey);
            }
        }

        // Global instance for easy access
        const locationManager = new LocationManager();

        // Command-line style functions for direct use (now async)
        async function createLocation(name, channelId = '', readKey = '') {
            return await locationManager.createLocation({ name, channelId, readKey });
        }

        async function getLocation(id) {
            return await locationManager.getLocationById(id);
        }

        async function updateLocation(id, updates) {
            return await locationManager.updateLocation(id, updates);
        }

        async function deleteLocation(id) {
            return await locationManager.deleteLocation(id);
        }

        async function listLocations() {
            return await locationManager.getAllLocations();
        }

        async function exportLocations() {
            return await locationManager.exportToJSON();
        }

        async function importLocations(jsonString) {
            return await locationManager.importFromJSON(jsonString);
        }

        // ThingSpeak integration helper
        async function testThingSpeakConnection(channelId, readKey) {
            try {
                const url = `https://api.thingspeak.com/channels/${channelId}/feeds.json?api_key=${readKey}&results=1`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();
                return {
                    success: true,
                    message: 'Connection successful',
                    hasData: data.feeds && data.feeds.length > 0
                };
            } catch (error) {
                return {
                    success: false,
                    message: error.message
                };
            }
        }

        // Database connection test
        async function testDatabaseConnection() {
            try {
                console.log('üß™ Testing database connection from dashboard...');
                const locations = await locationManager.getAllLocations();
                console.log('‚úÖ Database connection successful. Locations:', locations.length);
                return { success: true, locations: locations.length };
            } catch (error) {
                console.error('‚ùå Database connection failed:', error);
                return { success: false, error: error.message };
            }
        }

        // Make functions available globally
        window.LocationManager = LocationManager;
        window.locationManager = locationManager;
        window.createLocation = createLocation;
        window.getLocation = getLocation;
        window.updateLocation = updateLocation;
        window.deleteLocation = deleteLocation;
        window.listLocations = listLocations;
        window.exportLocations = exportLocations;
        window.importLocations = importLocations;
        window.testThingSpeakConnection = testThingSpeakConnection;
        window.testDatabaseConnection = testDatabaseConnection;
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        /* Pulse animation for the online dot */
        @keyframes ping-slow {
            75%, 100% { transform: scale(2); opacity: 0; }
        }
        .animate-ping-slow {
            animation: ping-slow 2s cubic-bezier(0, 0, 0.2, 1) infinite;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 min-h-screen flex flex-col">

    <!-- Navigation / Header -->
    <nav class="bg-white shadow-sm border-b border-slate-200 z-20 relative">
        <div class="px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16 items-center">
                <div class="flex items-center gap-3 cursor-pointer" onclick="goHome()">
                    <div class="bg-blue-600 text-white p-2 rounded-lg">
                        <i class="fa-solid fa-wind"></i>
                    </div>
                    <span id="brand-title" class="font-bold text-xl tracking-tight text-slate-900">CampusAir<span class="text-blue-600">Guard</span></span>
                </div>
                <div class="flex items-center gap-4">
                    <!-- Status Badge (Always visible in Dashboard) -->
                    <div id="status-badge" class="flex items-center gap-2 px-3 py-1 rounded-full text-xs font-medium bg-slate-100 text-slate-500 transition-colors duration-300">
                        <span class="relative flex h-2 w-2">
                          <span id="status-ping" class="hidden absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75 animate-ping-slow"></span>
                          <span id="status-dot" class="relative inline-flex rounded-full h-2 w-2 bg-slate-400 transition-colors duration-300"></span>
                        </span>
                        <span id="status-text">System Offline</span>
                    </div>

                    <!-- Nav Buttons -->
                    <button id="home-btn" onclick="goHome()" class="text-slate-500 hover:text-slate-700 font-medium text-sm">
                        <i class="fa-solid fa-arrow-left mr-1"></i> Back to Map
                    </button>

                    <button id="settings-btn" onclick="toggleSettings()" class="text-slate-500 hover:text-slate-700 transition-colors p-2 rounded-full hover:bg-slate-100" title="Settings">
                        <i class="fa-solid fa-gear text-lg"></i>
                    </button>

                    <button onclick="testDatabaseConnection().then(result => alert(result.success ? '‚úÖ Database OK: ' + result.locations + ' locations' : '‚ùå Database Error: ' + result.error))" class="text-slate-500 hover:text-slate-700 transition-colors p-2 rounded-full hover:bg-slate-100" title="Test Database">
                        <i class="fa-solid fa-database text-lg"></i>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- DASHBOARD CONTENT -->
    <div class="flex-grow p-4 sm:p-6 lg:p-8 max-w-7xl mx-auto w-full">

        <!-- Header Section -->
        <div class="mb-8 flex flex-col sm:flex-row sm:items-end justify-between gap-4">
            <div>
                <h1 id="dash-title" class="text-2xl sm:text-3xl font-bold text-slate-900">Dashboard</h1>
                <p id="dash-subtitle" class="text-slate-500 mt-1">Real-time monitoring</p>
            </div>
            <div class="text-sm text-slate-400 font-medium">
                Last Update: <span id="last-update-time" class="text-slate-700">--:--:--</span>
            </div>
        </div>

        <!-- Metrics Grid -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">

            <!-- CO2 Card -->
            <div class="glass-panel bg-white rounded-2xl shadow-sm border border-slate-200 p-6 relative overflow-hidden group hover:shadow-md transition-shadow">
                <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
                    <i class="fa-solid fa-cloud text-8xl text-slate-800"></i>
                </div>

                <div class="flex justify-between items-start mb-4 relative z-10">
                    <div>
                        <h3 class="text-slate-500 font-medium text-sm uppercase tracking-wider">Carbon Dioxide (CO2)</h3>
                        <div class="flex items-baseline gap-2 mt-2">
                            <span id="co2-value" class="text-5xl font-bold text-slate-900">--</span>
                            <span class="text-xl text-slate-400 font-medium">ppm</span>
                        </div>
                    </div>
                    <div id="co2-indicator" class="h-12 w-12 rounded-full bg-slate-100 flex items-center justify-center text-slate-400 transition-colors duration-500">
                        <i class="fa-solid fa-leaf text-xl"></i>
                    </div>
                </div>

                <div class="mt-4 relative z-10">
                    <div class="w-full bg-slate-100 rounded-full h-2 overflow-hidden">
                        <div id="co2-bar" class="bg-slate-400 h-2 rounded-full transition-all duration-1000" style="width: 0%"></div>
                    </div>
                    <div class="flex justify-between mt-2 text-xs font-medium">
                        <span id="co2-status-text" class="text-slate-400">Waiting for data...</span>
                        <span class="text-slate-400">Target: &lt;1000 ppm</span>
                    </div>
                </div>
            </div>

            <!-- Temperature Card -->
            <div class="glass-panel bg-white rounded-2xl shadow-sm border border-slate-200 p-6 relative overflow-hidden group hover:shadow-md transition-shadow">
                <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
                    <i class="fa-solid fa-thermometer-half text-8xl text-orange-600"></i>
                </div>

                <div class="flex justify-between items-start mb-4 relative z-10">
                    <div>
                        <h3 class="text-slate-500 font-medium text-sm uppercase tracking-wider">Temperature</h3>
                        <div class="flex items-baseline gap-2 mt-2">
                            <span id="temp-value" class="text-5xl font-bold text-slate-900">--</span>
                            <span class="text-xl text-slate-400 font-medium">¬∞C</span>
                        </div>
                    </div>
                    <div id="temp-indicator" class="h-12 w-12 rounded-full bg-orange-50 flex items-center justify-center text-orange-600">
                        <i class="fa-solid fa-temperature-half text-xl"></i>
                    </div>
                </div>

                <div class="mt-4 relative z-10">
                    <div class="w-full bg-slate-100 rounded-full h-2 overflow-hidden">
                        <div id="temp-bar" class="bg-orange-400 h-2 rounded-full transition-all duration-1000" style="width: 0%"></div>
                    </div>
                    <div class="flex justify-between mt-2 text-xs font-medium">
                        <span id="temp-status-text" class="text-slate-400">Waiting for data...</span>
                        <span class="text-slate-400">Ideal: 18¬∞C - 26¬∞C</span>
                    </div>
                </div>
            </div>

            <!-- Humidity Card -->
            <div class="glass-panel bg-white rounded-2xl shadow-sm border border-slate-200 p-6 relative overflow-hidden group hover:shadow-md transition-shadow">
                <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
                    <i class="fa-solid fa-droplet text-8xl text-blue-800"></i>
                </div>

                <div class="flex justify-between items-start mb-4 relative z-10">
                    <div>
                        <h3 class="text-slate-500 font-medium text-sm uppercase tracking-wider">Relative Humidity</h3>
                        <div class="flex items-baseline gap-2 mt-2">
                            <span id="humidity-value" class="text-5xl font-bold text-slate-900">--</span>
                            <span class="text-xl text-slate-400 font-medium">%</span>
                        </div>
                    </div>
                    <div id="humidity-indicator" class="h-12 w-12 rounded-full bg-blue-50 flex items-center justify-center text-blue-500">
                        <i class="fa-solid fa-water text-xl"></i>
                    </div>
                </div>

                <div class="mt-4 relative z-10">
                    <div class="w-full bg-slate-100 rounded-full h-2 overflow-hidden">
                        <div id="humidity-bar" class="bg-blue-500 h-2 rounded-full transition-all duration-1000" style="width: 0%"></div>
                    </div>
                    <div class="flex justify-between mt-2 text-xs font-medium">
                        <span id="humidity-status-text" class="text-slate-400">Waiting for data...</span>
                        <span class="text-slate-400">Ideal: 30% - 60%</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts Section -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
                <h3 class="font-bold text-slate-800 mb-4">CO2 History (Last 20 Points)</h3>
                <div class="relative h-64 w-full">
                    <canvas id="co2Chart"></canvas>
                </div>
            </div>
            <div class="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
                <div class="mb-4">
                    <h3 class="font-bold text-slate-800">Temperature History (Today)</h3>
                </div>
                <div class="relative h-64 w-full">
                    <canvas id="tempChart"></canvas>
                </div>
            </div>
            <div class="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
                <h3 class="font-bold text-slate-800 mb-4">Humidity History (Today)</h3>
                <div class="relative h-64 w-full">
                    <canvas id="humidityChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings/Edit Modal -->
    <div id="settings-modal" class="fixed inset-0 bg-slate-900/50 backdrop-blur-sm z-50 hidden items-center justify-center">
        <div class="bg-white rounded-2xl shadow-2xl p-6 w-full max-w-md m-4">
            <div class="flex justify-between items-center mb-6">
                <h2 id="modal-title" class="text-xl font-bold text-slate-900">Edit Location</h2>
                <button onclick="toggleSettings()" class="text-slate-400 hover:text-slate-600">
                    <i class="fa-solid fa-times text-xl"></i>
                </button>
            </div>

            <div class="space-y-4">
                <input type="hidden" id="edit-id">
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">Location Name</label>
                    <input type="text" id="loc-name-input" placeholder="e.g., Main Library" class="w-full px-4 py-2 rounded-lg border border-slate-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all">
                </div>
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">ThingSpeak Channel ID</label>
                    <input type="text" id="channel-id-input" placeholder="e.g., 123456" class="w-full px-4 py-2 rounded-lg border border-slate-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all">
                </div>
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">Read API Key</label>
                    <input type="password" id="api-key-input" placeholder="e.g., ABC123XYZ" class="w-full px-4 py-2 rounded-lg border border-slate-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all">
                </div>

                <div class="space-y-3">
                    <div class="bg-blue-50 p-4 rounded-lg flex items-start gap-3">
                        <i class="fa-solid fa-circle-info text-blue-500 mt-1"></i>
                        <div class="text-xs text-blue-700">
                            <strong>Keyboard Shortcuts:</strong><br>
                            <kbd class="px-1 py-0.5 bg-blue-100 rounded text-xs">Esc</kbd> Close modal<br>
                            <kbd class="px-1 py-0.5 bg-blue-100 rounded text-xs">Ctrl+N</kbd> New location<br>
                            <kbd class="px-1 py-0.5 bg-blue-100 rounded text-xs">Ctrl+H</kbd> Go home
                        </div>
                    </div>
                </div>
            </div>

            <div class="mt-6 flex gap-3">
                <button onclick="deleteLocation()" id="delete-btn" class="px-4 py-2 text-red-600 hover:bg-red-50 rounded-lg transition-colors font-medium">Delete</button>
                <button onclick="saveSettings()" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 rounded-lg transition-colors">
                    Save Location
                </button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>
        let currentLocId = null;
        let fetchInterval = null;
        let isLoading = false;

        // Get location ID from URL parameter
        function getLocationIdFromUrl() {
            // Extract location ID from URL path: /dashboard/location_id
            const pathParts = window.location.pathname.split('/');
            const dashboardIndex = pathParts.indexOf('dashboard');
            if (dashboardIndex !== -1 && pathParts.length > dashboardIndex + 1) {
                return decodeURIComponent(pathParts[dashboardIndex + 1]);
            }
            return null;
        }

        function goHome() {
            // Stop fetching specific data
            if(fetchInterval) clearInterval(fetchInterval);
            // Navigate back to home page
            window.location.href = '/';
        }

        function toggleSettings() {
            if(currentLocId) {
                openEditModal(currentLocId);
            } else {
                document.getElementById('settings-modal').classList.add('hidden');
            }
        }

        function openEditModal(id, isNew = false) {
            const modal = document.getElementById('settings-modal');
            const loc = locationManager.getLocationById(id) || { id: id, name: '', channelId: '', readKey: '' };

            document.getElementById('edit-id').value = id;
            document.getElementById('loc-name-input').value = loc.name;
            document.getElementById('channel-id-input').value = loc.channelId;
            document.getElementById('api-key-input').value = loc.readKey;

            document.getElementById('modal-title').innerText = isNew ? "Add Location" : "Edit Location";
            document.getElementById('delete-btn').style.display = isNew ? 'none' : 'block';

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        async function saveSettings() {
            const id = document.getElementById('edit-id').value;
            const name = document.getElementById('loc-name-input').value.trim();
            const cId = document.getElementById('channel-id-input').value.trim();
            const key = document.getElementById('api-key-input').value.trim();

            // Validation
            if (!name) {
                alert('Please enter a location name');
                document.getElementById('loc-name-input').focus();
                return;
            }

            if (cId && !/^\d+$/.test(cId)) {
                alert('Channel ID must be numeric');
                document.getElementById('channel-id-input').focus();
                return;
            }

            if (key && key.length < 16) {
                alert('API key appears to be too short');
                document.getElementById('api-key-input').focus();
                return;
            }

            const locationData = {
                name: name || 'Unnamed Location',
                channelId: cId,
                readKey: key
            };

            try {
                const existingLocation = await locationManager.getLocationById(id);

                if(existingLocation) {
                    // Update existing location
                    await locationManager.updateLocation(id, locationData);
                } else {
                    // Create new location
                    await locationManager.createLocation(locationData);
                }

                // Close modal
                document.getElementById('settings-modal').classList.add('hidden');
                document.getElementById('settings-modal').classList.remove('flex');

                // Reload dashboard with updated data
                await init();
            } catch (error) {
                console.error('Error saving location:', error);
                alert('Error saving location. Please try again.');
            }
        }

        function deleteLocation() {
            const id = document.getElementById('edit-id').value;
            if(confirm('Are you sure you want to delete this location?')) {
                locationManager.deleteLocation(id);

                document.getElementById('settings-modal').classList.add('hidden');
                document.getElementById('settings-modal').classList.remove('flex');

                // Go back to home since location was deleted
                goHome();
            }
        }

        // --- Chart Initialization (Shared) ---
        const commonChartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            scales: {
                x: { grid: { display: false }, ticks: { maxTicksLimit: 6 } },
                y: { beginAtZero: false, grid: { borderDash: [5, 5] } }
            },
            elements: {
                line: { tension: 0.4, borderWidth: 2 },
                point: { radius: 2, hitRadius: 10 }
            },
            animation: false
        };

        const co2Ctx = document.getElementById('co2Chart').getContext('2d');
        let co2Chart = new Chart(co2Ctx, {
            type: 'line',
            data: { labels: [], datasets: [{ data: [], borderColor: '#10b981', backgroundColor: 'rgba(16, 185, 129, 0.1)', fill: true }] },
            options: { ...commonChartOptions, scales: { ...commonChartOptions.scales, y: { suggestedMin: 300, suggestedMax: 1000 } } }
        });

        const humCtx = document.getElementById('humidityChart').getContext('2d');
        let humidityChart = new Chart(humCtx, {
            type: 'line',
            data: { labels: [], datasets: [{ data: [], borderColor: '#3b82f6', backgroundColor: 'rgba(59, 130, 246, 0.1)', fill: true }] },
            options: { ...commonChartOptions, scales: { ...commonChartOptions.scales, y: { suggestedMin: 0, suggestedMax: 100 } } }
        });

        const tempCtx = document.getElementById('tempChart').getContext('2d');
        let tempChart = new Chart(tempCtx, {
            type: 'line',
            data: { labels: [], datasets: [{ data: [], borderColor: '#f97316', backgroundColor: 'rgba(249, 115, 22, 0.08)', fill: true }] },
            options: { ...commonChartOptions, scales: { ...commonChartOptions.scales, y: { suggestedMin: -10, suggestedMax: 50 } } }
        });
        
        // Helper to compute min/max with padding
        function computeRange(dataArray, paddingRatio = 0.1, clampMin = undefined, clampMax = undefined) {
            const nums = (dataArray || []).filter(v => v !== null && v !== undefined && !isNaN(v)).map(Number);
            if (!nums.length) return null;
            let min = Math.min(...nums);
            let max = Math.max(...nums);
            let padding = (max - min) * paddingRatio;
            if (padding === 0) padding = 1;
            let outMin = typeof clampMin === 'number' ? Math.max(clampMin, min - padding) : min - padding;
            let outMax = typeof clampMax === 'number' ? Math.min(clampMax, max + padding) : max + padding;
            if (outMin >= outMax) { outMin = min - 1; outMax = max + 1; }
            return { min: outMin, max: outMax };
        }

        // Rebuild a line chart to avoid resolver/scriptable issues when changing scales
        function rebuildLineChart(oldChart, ctx, labels, dataArray, color, bgColor, yRange) {
            try { if (oldChart) oldChart.destroy(); } catch(e){ console.warn('destroy chart failed', e); }
            return new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: [{ data: dataArray, borderColor: color, backgroundColor: bgColor, fill: true }] },
                options: { ...commonChartOptions, scales: { ...commonChartOptions.scales, y: { suggestedMin: yRange ? yRange.min : undefined, suggestedMax: yRange ? yRange.max : undefined } } }
            });
        }
        
        // Full datasets and windowing state for zooming
        let fullLabels = [];
        let fullCo2Data = [];
        let fullTempData = [];
        let fullHumData = [];
        let windowStart = 0;
        let windowSize = 0;

        function applyWindowAndRebuild() {
            const start = Math.max(0, Math.min(windowStart, Math.max(0, fullLabels.length - 1)));
            const size = Math.max(1, Math.min(windowSize || fullLabels.length, fullLabels.length));
            const end = Math.min(fullLabels.length, start + size);

            const visLabels = fullLabels.slice(start, end);
            const visCo2 = fullCo2Data.slice(start, end);
            const visTemp = fullTempData.slice(start, end);
            const visHum = fullHumData.slice(start, end);

            const co2Range = computeRange(visCo2, 0.12, 0, undefined);
            const tempRange = computeRange(visTemp, 0.12, -10, 50);
            const humRange = computeRange(visHum, 0.08, 0, 100);

            co2Chart = rebuildLineChart(co2Chart, co2Ctx, visLabels, visCo2, '#10b981', 'rgba(16, 185, 129, 0.1)', co2Range);
            tempChart = rebuildLineChart(tempChart, tempCtx, visLabels, visTemp, '#f97316', 'rgba(249, 115, 22, 0.08)', tempRange);
            humidityChart = rebuildLineChart(humidityChart, humCtx, visLabels, visHum, '#3b82f6', 'rgba(59, 130, 246, 0.1)', humRange);
            // Reattach interactions to the new canvases
            attachCanvasInteractions();
        }

        function zoomIn() {
            if (!windowSize) windowSize = fullLabels.length;
            let newSize = Math.max(5, Math.floor(windowSize / 2));
            const center = Math.floor(windowStart + windowSize / 2);
            windowSize = newSize;
            windowStart = Math.max(0, center - Math.floor(windowSize / 2));
            applyWindowAndRebuild();
        }

        function zoomOut() {
            if (!windowSize) windowSize = fullLabels.length;
            let newSize = Math.min(fullLabels.length, windowSize * 2);
            const center = Math.floor(windowStart + windowSize / 2);
            windowSize = newSize;
            windowStart = Math.max(0, center - Math.floor(windowSize / 2));
            if (windowStart + windowSize > fullLabels.length) windowStart = Math.max(0, fullLabels.length - windowSize);
            applyWindowAndRebuild();
        }

        function resetZoom() {
            windowStart = 0;
            windowSize = fullLabels.length;
            applyWindowAndRebuild();
        }

        // Mouse interactions: wheel zoom and drag pan
        function attachCanvasInteractions() {
            const canvases = [co2Chart.canvas, tempChart.canvas, humidityChart.canvas];
            canvases.forEach(canvas => {
                if (!canvas) return;
                // Cleanup previous handlers if present
                if (canvas._zoomCleanup) canvas._zoomCleanup();

                // Wheel to zoom
                const onWheel = (e) => {
                    e.preventDefault();
                    if (!fullLabels.length) return;
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const cw = rect.width || canvas.width;
                    const rel = Math.max(0, Math.min(1, x / cw));
                    const focalIndex = Math.floor(windowStart + rel * windowSize);

                    const zoomFactor = e.deltaY < 0 ? 0.7 : 1.3; // wheel up zoom in
                    const minSize = 5;
                    const maxSize = fullLabels.length || 1;
                    let newSize = Math.round(Math.max(minSize, Math.min(maxSize, windowSize * zoomFactor)));
                    const centerOffset = focalIndex - windowStart;
                    const newStart = Math.max(0, Math.min(fullLabels.length - newSize, focalIndex - Math.round((centerOffset / windowSize) * newSize)));
                    windowSize = newSize;
                    windowStart = newStart;
                    applyWindowAndRebuild();
                };

                // Drag to pan
                let dragging = false;
                let lastX = 0;
                const onMouseDown = (e) => {
                    dragging = true;
                    lastX = e.clientX;
                    canvas.style.cursor = 'grabbing';
                };
                const onMouseMove = (e) => {
                    if (!dragging || !fullLabels.length) return;
                    const rect = canvas.getBoundingClientRect();
                    const dx = e.clientX - lastX;
                    lastX = e.clientX;
                    const deltaIndices = Math.round((dx / rect.width) * windowSize);
                    windowStart = Math.max(0, Math.min(fullLabels.length - windowSize, windowStart - deltaIndices));
                    applyWindowAndRebuild();
                };
                const onMouseUp = () => {
                    dragging = false;
                    canvas.style.cursor = 'default';
                };

                canvas.addEventListener('wheel', onWheel, { passive: false });
                canvas.addEventListener('mousedown', onMouseDown);
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);

                // store cleanup
                canvas._zoomCleanup = () => {
                    canvas.removeEventListener('wheel', onWheel);
                    canvas.removeEventListener('mousedown', onMouseDown);
                    window.removeEventListener('mousemove', onMouseMove);
                    window.removeEventListener('mouseup', onMouseUp);
                    delete canvas._zoomCleanup;
                };
            });
        }

        // Adjust y-axis scale dynamically based on dataset values (with padding and optional clamps)
        function adjustYAxis(chart, dataArray, options = {}) {
            try {
                const nums = (dataArray || []).filter(v => v !== null && v !== undefined && !isNaN(v)).map(Number);
                if (!nums.length) return;
                let min = Math.min(...nums);
                let max = Math.max(...nums);

                // padding ratio (default 10%)
                const paddingRatio = typeof options.paddingRatio === 'number' ? options.paddingRatio : 0.1;
                let padding = (max - min) * paddingRatio;
                if (padding === 0) padding = options.minPadding || 1;

                let clampedMin = (typeof options.clampMin === 'number') ? Math.max(options.clampMin, min - padding) : min - padding;
                let clampedMax = (typeof options.clampMax === 'number') ? Math.min(options.clampMax, max + padding) : max + padding;

                // ensure min < max
                if (clampedMin >= clampedMax) {
                    clampedMin = min - 1;
                    clampedMax = max + 1;
                }

                chart.options.scales = chart.options.scales || {};
                chart.options.scales.y = chart.options.scales.y || {};
                // Use suggestedMin/suggestedMax to avoid scriptable resolver issues
                chart.options.scales.y.suggestedMin = clampedMin;
                chart.options.scales.y.suggestedMax = clampedMax;
            } catch (e) {
                console.warn('adjustYAxis error', e);
            }
        }

        function clearCharts() {
            co2Chart.data.labels = [];
            co2Chart.data.datasets[0].data = [];
            co2Chart.update();
            humidityChart.data.labels = [];
            humidityChart.data.datasets[0].data = [];
            humidityChart.update();

            // Reset text
            document.getElementById('co2-value').innerText = '--';
            document.getElementById('temp-value').innerText = '--';
            document.getElementById('humidity-value').innerText = '--';
            document.getElementById('last-update-time').innerText = '--:--:--';
        }

        // --- Dashboard Data Logic ---

        function updateStatus(state) {
            const badge = document.getElementById('status-badge');
            const dot = document.getElementById('status-dot');
            const ping = document.getElementById('status-ping');
            const text = document.getElementById('status-text');

            if (state === 'online') {
                badge.className = "flex items-center gap-2 px-3 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800";
                dot.className = "relative inline-flex rounded-full h-2 w-2 bg-green-500";
                ping.classList.remove('hidden');
                text.innerText = "System Online";
            } else if (state === 'loading') {
                badge.className = "flex items-center gap-2 px-3 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800";
                dot.className = "relative inline-flex rounded-full h-2 w-2 bg-blue-500 animate-pulse";
                ping.classList.add('hidden');
                text.innerText = "Connecting...";
            } else {
                badge.className = "flex items-center gap-2 px-3 py-1 rounded-full text-xs font-medium bg-slate-200 text-slate-600";
                dot.className = "relative inline-flex rounded-full h-2 w-2 bg-slate-500";
                ping.classList.add('hidden');

                if (state === 'error') text.innerText = "Connection Error";
                else text.innerText = "System Offline";
            }
        }

        async function fetchData() {
            if(!currentLocId || isLoading) return;

            // Get latest location object from manager (async)
            const loc = await locationManager.getLocationById(currentLocId);
            if (!loc || !loc.channelId || !loc.readKey) {
                console.warn('fetchData: location not configured or missing credentials', loc);
                updateStatus('offline');
                return;
            }

            isLoading = true;
            updateStatus('loading');

            try {
                const url = `https://api.thingspeak.com/channels/${loc.channelId}/feeds.json?api_key=${loc.readKey}&results=20`;
                console.log('Fetching ThingSpeak URL:', url);

                const response = await fetch(url);
                console.log('ThingSpeak response status:', response.status, response.statusText);

                if (!response.ok) {
                    const text = await response.text().catch(()=>'<no body>');
                    console.error('ThingSpeak response not ok, body:', text);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('ThingSpeak data received. feeds length:', data.feeds ? data.feeds.length : 0);

                if (data.feeds && data.feeds.length > 0) {
                    // Stale check (5 mins)
                    const lastFeed = data.feeds[data.feeds.length - 1];
                    const feedTime = new Date(lastFeed.created_at).getTime();
                    const now = Date.now();

                    if (now - feedTime > 300000) { // 5 mins
                        updateStatus('offline');
                    } else {
                        updateStatus('online');
                    }

                    processFeeds(data.feeds);
                    // Save latest feed time to Firestore so home cards show last update
                    try {
                        const latestFeed = data.feeds[data.feeds.length - 1];
                        if (latestFeed && latestFeed.created_at) {
                            // lastUpdate is an ISO timestamp string from ThingSpeak
                            await locationManager.updateLocation(currentLocId, { lastUpdate: latestFeed.created_at });
                            console.log('Saved lastUpdate to Firestore:', latestFeed.created_at);
                        }
                    } catch (e) {
                        console.warn('Could not save lastUpdate to Firestore:', e);
                    }
                } else {
                    updateStatus('online'); // Connected, just empty
                    document.getElementById('co2-status-text').innerText = "Channel Empty";
                    document.getElementById('humidity-status-text').innerText = "Channel Empty";
                }
            } catch (error) {
                console.error("Fetch error:", error);
                updateStatus('error');
                // Show error message in status texts
                document.getElementById('co2-status-text').innerText = "Connection Failed";
                document.getElementById('humidity-status-text').innerText = "Connection Failed";
            } finally {
                isLoading = false;
            }
        }

        function processFeeds(feeds) {
            // Build arrays for today's data (local date)
            const today = new Date();
            const tYear = today.getFullYear(), tMonth = today.getMonth(), tDate = today.getDate();

            const labels = [];
            const co2Data = [];
            const tempData = [];
            const humData = [];

            feeds.forEach(feed => {
                if (feed.field1 !== null) {
                    const date = new Date(feed.created_at);
                    // include only feeds from same local day
                    if (date.getFullYear() === tYear && date.getMonth() === tMonth && date.getDate() === tDate) {
                        const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        labels.push(timeStr);
                        co2Data.push(parseFloat(feed.field1));
                        // field2 = Temperature, field3 = Humidity
                        tempData.push(feed.field2 !== null && feed.field2 !== undefined ? parseFloat(feed.field2) : null);
                        humData.push(feed.field3 !== null && feed.field3 !== undefined ? parseFloat(feed.field3) : null);
                    }
                }
            });

            // If no feeds for today, fallback to last N feeds
            if (labels.length === 0 && feeds.length > 0) {
                feeds.forEach(feed => {
                    if (feed.field1 !== null) {
                        const date = new Date(feed.created_at);
                        const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        labels.push(timeStr);
                        co2Data.push(parseFloat(feed.field1));
                        tempData.push(feed.field2 !== null && feed.field2 !== undefined ? parseFloat(feed.field2) : null);
                        humData.push(feed.field3 !== null && feed.field3 !== undefined ? parseFloat(feed.field3) : null);
                    }
                });
            }

            // Populate the full datasets for zooming
            fullLabels = labels;
            fullCo2Data = co2Data;
            fullTempData = tempData;
            fullHumData = humData;
            windowStart = 0;
            windowSize = fullLabels.length;

            // Choose latest feed to display in cards: prefer today's last feed, otherwise the last overall
            let latestFeed = null;
            if (labels.length > 0) {
                // pick last matching today's feed
                for (let i = feeds.length - 1; i >= 0; i--) {
                    const d = new Date(feeds[i].created_at);
                    if (d.getFullYear() === tYear && d.getMonth() === tMonth && d.getDate() === tDate) {
                        latestFeed = feeds[i];
                        break;
                    }
                }
            }
            if (!latestFeed) latestFeed = feeds[feeds.length - 1];

            if (latestFeed) {
                updateDashboard(latestFeed.field1, latestFeed.field2, latestFeed.field3, latestFeed.created_at);
            }

            // Build visible window and rebuild charts
            applyWindowAndRebuild();
        }

        function updateDashboard(co2, temp, hum, timestamp) {
            // Update last-update time if provided
            if (timestamp) {
                const date = new Date(timestamp);
                document.getElementById('last-update-time').innerText = date.toLocaleTimeString();
            }

            // Update CO2 if provided
            if (co2 !== null && co2 !== undefined) {
                const co2Val = Math.round(co2);
                document.getElementById('co2-value').innerText = co2Val;
                const co2Bar = document.getElementById('co2-bar');
                const co2Ind = document.getElementById('co2-indicator');
                const co2Text = document.getElementById('co2-status-text');
                const co2Percent = Math.min(100, (co2Val / 2000) * 100);
                co2Bar.style.width = `${co2Percent}%`;

                if (co2Val < 800) {
                    co2Ind.className = "h-12 w-12 rounded-full flex items-center justify-center transition-colors duration-500 bg-green-100 text-green-600";
                    co2Bar.className = "h-2 rounded-full transition-all duration-1000 bg-green-500";
                    co2Text.innerText = "Excellent Quality";
                    co2Text.className = "text-green-600 font-bold";
                } else if (co2Val < 1200) {
                    co2Ind.className = "h-12 w-12 rounded-full flex items-center justify-center transition-colors duration-500 bg-yellow-100 text-yellow-600";
                    co2Bar.className = "h-2 rounded-full transition-all duration-1000 bg-yellow-500";
                    co2Text.innerText = "Moderate Quality";
                    co2Text.className = "text-yellow-600 font-bold";
                } else {
                    co2Ind.className = "h-12 w-12 rounded-full flex items-center justify-center transition-colors duration-500 bg-red-100 text-red-600";
                    co2Bar.className = "h-2 rounded-full transition-all duration-1000 bg-red-500";
                    co2Text.innerText = "Poor Quality (Ventilate)";
                    co2Text.className = "text-red-600 font-bold";
                }
            }

            // Update Temperature if provided (display with one decimal place)
            if (temp !== null && temp !== undefined && !isNaN(temp)) {
                const tempNum = Number(temp);
                const tempDisplay = tempNum.toFixed(1);
                document.getElementById('temp-value').innerText = tempDisplay;
                const tempBar = document.getElementById('temp-bar');
                const tempText = document.getElementById('temp-status-text');
                // scale temp for bar width (approx between -10 to 50)
                const percent = Math.min(100, Math.max(0, ((tempNum + 10) / 60) * 100));
                tempBar.style.width = `${percent}%`;
                if (tempNum >= 18 && tempNum <= 26) {
                    tempText.innerText = "Comfortable";
                    tempText.className = "text-green-600 font-bold";
                } else {
                    tempText.innerText = tempNum < 18 ? "Cool" : "Warm";
                    tempText.className = "text-orange-600 font-bold";
                }
            }

            // Update Humidity if provided (display with one decimal place)
            if (hum !== null && hum !== undefined && !isNaN(hum)) {
                const humNum = Number(hum);
                const humDisplay = humNum.toFixed(1);
                document.getElementById('humidity-value').innerText = humDisplay;
                const humBar = document.getElementById('humidity-bar');
                const humInd = document.getElementById('humidity-indicator');
                const humText = document.getElementById('humidity-status-text');
                const humPercent = Math.min(100, Math.max(0, humNum));
                humBar.style.width = `${humPercent}%`;

                if (humNum >= 30 && humNum <= 60) {
                    humInd.className = "h-12 w-12 rounded-full flex items-center justify-center transition-colors duration-500 bg-blue-100 text-blue-600";
                    humText.innerText = "Comfortable";
                    humText.className = "text-blue-600 font-bold";
                } else {
                    humInd.className = "h-12 w-12 rounded-full flex items-center justify-center transition-colors duration-500 bg-orange-100 text-orange-600";
                    humText.innerText = humNum < 30 ? "Dry Air" : "High Humidity";
                    humText.className = "text-orange-600 font-bold";
                }
            }
        }

        // --- Keyboard Shortcuts and Utilities ---

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // ESC to close modal
            if (e.key === 'Escape') {
                const modal = document.getElementById('settings-modal');
                if (!modal.classList.contains('hidden')) {
                    toggleSettings();
                }
            }

            // Ctrl/Cmd + H for home
            if ((e.ctrlKey || e.metaKey) && e.key === 'h') {
                e.preventDefault();
                goHome();
            }
        });

        // --- Start App ---
        async function init() {
            // Initialize LocationManager first
            try {
                console.log('üîÑ Initializing LocationManager...');
                await locationManager.initialize();
                console.log('‚úÖ LocationManager initialized with Firestore');
            } catch (error) {
                console.error('‚ùå Failed to initialize LocationManager:', error);
                alert('Database connection failed. Check Firebase configuration.');
                window.location.href = '/';
                return;
            }

            const locationId = getLocationIdFromUrl();
            console.log('üìç Location ID from URL:', locationId);

            if (!locationId) {
                // No location specified, redirect to home
                console.error('‚ùå No location ID in URL');
                window.location.href = '/';
                return;
            }

            const loc = await locationManager.getLocationById(locationId);
            console.log('üîç Location lookup result:', loc);

            if (!loc) {
                // Location doesn't exist, redirect to home
                console.error('‚ùå Location not found in database:', locationId);
                alert('Location not found in database. It may have been deleted.');
                window.location.href = '/';
                return;
            }

            currentLocId = locationId;

            // Set Titles
            document.getElementById('dash-title').innerText = loc.name;
            document.getElementById('dash-subtitle').innerText = `ID: ${loc.channelId || 'Not Configured'}`;
            // Update document title to include location name
            try {
                document.title = `${loc.name} ‚Äî CampusAirGuard Dashboard`;
            } catch (e) {
                console.warn('Could not set document.title', e);
            }
            // Leave navbar brand HTML unchanged (avoid overwriting styled markup)

            // Reset Charts & UI
            clearCharts();
            updateStatus('offline'); // Default to offline until fetch succeeds

            // Start Fetch Loop
            fetchData();
            fetchInterval = setInterval(fetchData, 15000);
        }

        // Initialize when page loads
        init();
    </script>
</body>
</html>
